/// <reference types="node" />
import { WritePngFileCallback } from "./encode";
import { ColorRGB, ColorRGBA, ColorGrayScale, ColorPalette, Palette, ColorAny, ColorNoAlpha } from "./colors";
import { XY } from "./xy";
import { Rect } from "./rect";
import { ColorType } from "./color-type";
/**
 * The interlace type from libpng.
 */
export declare enum InterlaceType {
    /**
     * Libpng interlace type `PNG_INTERLACE_NONE` (0).
     */
    NONE = "none",
    /**
     * Libpng interlace type `PNG_INTERLACE_ADAM7` (1).
     */
    ADAM7 = "adam7",
    /**
     * Interlace type parsing failed.
     */
    UNKNOWN = "unknown"
}
/**
 * Argument configuration for calling `PngImage.resizeCanvas`.
 */
export interface ResizeCanvasArguments {
    /**
     * The dimensions the new image should have.
     */
    readonly dimensions?: XY;
    /**
     * An optional offset to offset the old image with. Will be applied to the top-left of the image.
     * This will make the clipped image moved to the right and down by the specified amount of pixels
     * and create a border on the top and to the left.
     */
    readonly offset?: XY;
    /**
     * Specify this to clip the image in addition to resizing the canvas. This will remove parts of the image
     * by only using the specified rectangle.
     * In combination with reducing the dimensions this can be used to crop the image.
     */
    readonly clip?: Rect;
    /**
     * When enlarging the canvas an empty are will be created. It will be filled with this color.
     */
    readonly fillColor?: ColorAny;
}
/**
 * Converts the native time from the libpng bindings into a javascript `Date` object.
 *
 * @param nativeTime The time as returned by the bindings.
 *
 * @return The time converted to a javascript `Date` object or `undefined` if the time was
 *         not set in the PNG's header.
 */
export declare function convertNativeTime(nativeTime: any): Date;
/**
 * Converts the background color from the libpng bindings into a color.
 *
 * @param nativeBackgroundColor The background color as returned by the native bindings.
 * @param colorType The color type of the image of which the background color should be converted.
 *
 * @return The converted background color in `ColorRGB`, `ColorPalette` or `ColorGrayScale` format
 *         or undefined if the background color was not set in the PNG.
 */
export declare function convertNativeBackgroundColor(nativeBackgroundColor: any, colorType: ColorType): ColorNoAlpha;
/**
 * Decodes and wraps a PNG image. Will call the native bindings under the hood and provides
 * a high-level access to read- and write operations on the image.
 */
export declare class PngImage {
    constructor(buffer: Buffer);
    /**
     * The bit depth of the image.
     * Gathered from `png_get_bit_depth`.
     */
    bitDepth: number;
    /**
     * The amount of channels of the image.
     * Gathered from `png_get_channels`.
     */
    channels: number;
    /**
     * The color type of the image as a string.
     * Gathered from `png_get_color_type`.
     */
    colorType: ColorType;
    /**
     * The width of the image.
     * Gathered from `png_get_image_height`.
     */
    height: number;
    /**
     * The width of the image.
     * Gathered from `png_get_image_width`.
     */
    width: number;
    /**
     * The interlace type of the image as a string, gathered from `png_get_interlace_type`.
     */
    interlaceType: InterlaceType;
    /**
     * The amount of bytes per row of the image.
     * Gathered from `png_get_rowbytes`.
     */
    rowBytes: number;
    /**
     * The horizontal offset of the image.
     * Gathered from `png_get_x_offset_pixels`.
     */
    offsetX: number;
    /**
     * The vertical offset of the image.
     * Gathered from `png_get_y_offset_pixels`.
     */
    offsetY: number;
    /**
     * The horizontal amount of pixels per meter of the image.
     * Gathered from `png_get_x_pixels_per_meter`.
     */
    pixelsPerMeterX: number;
    /**
     * The vertical amount of pixels per meter of the image.
     * Gathered from `png_get_y_pixels_per_meter`.
     */
    pixelsPerMeterY: number;
    /**
     * The buffer containing the data of the decoded image.
     */
    data: Buffer;
    /**
     * Returns the last modification time as returned by `png_get_tIME`.
     */
    time: Date;
    /**
     * Returns the background color of the image if provided in the header.
     */
    backgroundColor: ColorRGB | ColorGrayScale | ColorPalette;
    /**
     * Retrieve the palette of this image if the color type is `ColorType.PALETTE`.
     *
     * @see ColorType
     */
    palette: Palette;
    /**
     * The gamma value of the image.
     * Gathered from `png_get_gAMA`.
     */
    gamma: number;
    /**
     * Will be `true` if the image's color type has an alpha channel and `false` otherwise.
     */
    get alpha(): boolean;
    /**
     * Returns the amount of bytes per pixel (depending on the color type) for the image.
     */
    get bytesPerPixel(): number;
    /**
     * Convert a set of coordinates to index in the buffer.
     */
    toIndex(x: number, y: number): number;
    /**
     * Convert an index in the buffer to a set of coordinates.
     */
    toXY(index: number): XY;
    /**
     * Retrieves the color in the image's color format at the specified position.
     *
     * @param x The x position of the pixel in the image of which to retrieve the color.
     * @param y The y position of the pixel in the image of which to retrieve the color.
     *
     * @return The color at the given pixel in the image's color format.
     */
    at(x: number, y: number): ColorAny;
    /**
     * Retrieves the color in rgba format, converting from the image's color format.
     * This will automatically convert from indexed or grayscale images to rgba. If
     * the image's color format doesn't provide an alpha channel, `255` is returned as alpha.
     *
     * @param x The x position of the pixel in the image of which to retrieve the color.
     * @param y The y position of the pixel in the image of which to retrieve the color.
     *
     * @return The color at the given pixel in rgba format.
     */
    rgbaAt(x: number, y: number): ColorRGBA;
    /**
     * A convenience wrapper around `resizeCanvas`. Crops the image to a specified sub-rectangle.
     * Modifies this image and the underlying buffer.
     *
     * @see PngImage.resizeCanvas
     * @see ResizeCanvasArguments
     *
     * @param clip A sub-rectangle which should be cropped out of the image.
     */
    crop(clip: Rect): void;
    /**
     * Resizes the canvas with while optionally adding padding and cropping regions from the image.
     * Modifies this image and the underlying buffer.
     *
     * @see ResizeCanvasArguments
     */
    resizeCanvas({ dimensions, offset, clip, fillColor }: ResizeCanvasArguments): void;
    /**
     * Copies the specified rectangle from the other image (or the whole other image if rectangle is omitted)
     * into this image at the current offset (or to the top left if the offset is omitted).
     * Modifies this image and the underlying buffer.
     *
     * @param other The other image which should be copied into this image.
     * @param offset The target position in this image to which the other image should be copied.
     * @param source The clipping rectangle of the other image which should be copied.
     */
    copyFrom(other: PngImage, offset?: XY, source?: Rect): void;
    /**
     * Fill an area of the image with a specific color.
     * This will change the underlying data of this image. The change is in-place.
     *
     * @param color The color with which the area should be filled.
     * @param area The area to fill. Can be omitted to fill the whole image.
     */
    fill(color: ColorAny, area?: Rect): void;
    /**
     * Set the color of one specific pixel on this image.
     * This will change the underlying data of this image. The change is in-place.
     *
     * @param color The color with which the area should be filled.
     * @param position The position of the pixel to colorize.
     */
    set(color: ColorAny, position: XY): void;
    /**
     * Will encode this image to a PNG buffer.
     */
    encode(): Buffer;
    /**
     * Will encode this image and write it to the file at the specified path.
     *
     * @param path Path to the file to which the encoded PNG should be written.
     * @param callback An optional callback to use instead of the Promise API.
     *
     * @see writePngFile
     *
     * @return A Promise which resolves once the file is written or `undefined` if a callback was specified.
     */
    write(path: string, callback?: WritePngFileCallback): Promise<void> | void;
    /**
     * Will encode this image and write it to the file at the specified path synchroneously.
     *
     * @param path Path to the file to which the encoded PNG should be written.
     *
     * @see writePngFileSync
     */
    writeSync(path: string): void;
}
